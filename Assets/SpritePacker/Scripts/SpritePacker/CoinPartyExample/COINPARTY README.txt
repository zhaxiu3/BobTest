Coin Party
-------------------------

This example is part of a documentation section on optimization for mobile devices. It demonstrates a clever way of getting around hardware limitations, given a simple enough problem to solve.

The problem was defined in the documentation as "Hundreds of rotating, dynamically lit, collectable coins onscreen at once." 

The naive approach is to Instantiate a bunch of copies of a coin prefab, but instead we are going to use particles to render our coins. However, this introduces a number of challenges that we have to overcome.

	- Viewing angles are a problem because particles don't have them.
		- We assume that the camera stays right-side up and the coins rotate around the Y-axis.
		- We create the illusion of coin rotation with an animated texture that we packed using the SpritePacker.
			- This introduces a new problem: Monotony of rotating coins all rotating at the same speed and in the same direction
			- We keep track of rotation and lifetime ourselves and "render" rotation to the particle lifetimes in script to fix this.
		
	- Normals are a problem because particles don't have them, and we need real time lighting.
		- Generate a single normal vector for the face of the coin in each animation frame generated by the Sprite Packer.
		- Do Blinn-Phong lighting for each particle in script, based on the normal vector grabbed from the above list.
		- Apply the result to the particle as a color.
		- Handle the face of the coin and the rim of the coin separately in the shader.
			- Introduces a new problem: How does the shader know where the rim is, and what part of the rim it's on?
				- Can't use UV's, they are already used for the animation.
				- Use a texture map.
					- Need Y-position relative to coin.
					- Need binary "on face" vs "on rim".
				- We don't want to introduce another texture, more texture reads, more texture memory.
				- Combine needed information into one channel and replace one of the texture's color channels with it.
					- Now our coin is the wrong color! What do we do?
					- Use the shader to reconstruct missing channel as a combination of the two remaining channels.
					
	- Say we want glow from light glinting off our coins. Post process is too expensive for mobile devices.
		- Create another particle system and give it a softened, glowy version of the coin animation.
		- Color a glow only when the corresponding coin's color is super bright.
		- Can't have glow rendered on every coin every frame - fill rate killer.
			- Reset glows every frame, only position ones with brightness > 0.
		
	- Physics is a problem, collecting coins is a problem - particles don't collide very well.
		- Could use built-in particle collision?
		- Instead, just wrote collision into the script.
		
	- Finally, we have one more problem - this script does a lot, and its getting slow!
		- Perfomance scales linearly with number of active coins.
			- Limit maximum coins. This works well enough to acheive our goal: 100 coins, 2 lights, runs really fast on mobile devices.
		
	- Things to try to optimize further:
		- Instead of calculating lighting for every coin individually, cut the world into chunks and calculate lighting conditions for every rotation frame in every chunk.
			- Use as a lookup table with coin position and coin rotation as indices.
			- Increase fidelity by using bilinear interpolation with position.
			- Sparse updates on the lookup table, or, entirely static lookup table.
			- Use Light Probes for this?
			
		- Instead of calculating lighting in script, use normal-mapped particles?
			- Use "Display Normals" shader to bake frame animation of normals.
			- Limits number of lights.
			- Fixes slow script problem.
		
		- Avoid cache-misses by putting our custom rotation and lifetime data into the particle struct somehow.